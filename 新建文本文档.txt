给你个任务，看你本事

package com.hbm.tileentity.machine;

import com.hbm.items.ModItems;
import com.hbm.items.machine.ItemLens;
import com.hbm.packet.AuxGaugePacket;
import com.hbm.packet.PacketDispatcher;
import com.hbm.tileentity.TileEntityMachineBase;

import api.hbm.energy.IEnergyUser;
import net.minecraft.init.Blocks;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.ITickable;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;
import net.minecraftforge.fml.common.network.NetworkRegistry.TargetPoint;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.jetbrains.annotations.NotNull;

public class TileEntityCoreStabilizer extends TileEntityMachineBase implements ITickable, IEnergyUser {

	public long power;
	public static final long maxPower = 10000000000000L;
	public int watts;
	public int beam;
	public boolean isOn;
	
	public static final int range = 15;
	
	public TileEntityCoreStabilizer() {
		super(1);
		
	}

	@Override
	public void update() {
		if(!world.isRemote) {

			this.updateStandardConnections(world, pos);
			
			watts = MathHelper.clamp(watts, 1, 100);
			long demand = (long) Math.pow(watts, 6);
			isOn = false;

			beam = 0;

			ItemLens lens = null;
			if(inventory.getStackInSlot(0).getItem() instanceof ItemLens){
				lens = (ItemLens) inventory.getStackInSlot(0).getItem();
			}

			if(lens != null && power >= demand * lens.drainMod) {
				isOn = true;
				EnumFacing dir = EnumFacing.byIndex(this.getBlockMetadata());
				for(int i = 1; i <= range; i++) {
	
					int x = pos.getX() + dir.getXOffset() * i;
					int y = pos.getY() + dir.getYOffset() * i;
					int z = pos.getZ() + dir.getZOffset() * i;
					BlockPos pos1 = new BlockPos(x, y, z);
					
					TileEntity te = world.getTileEntity(pos1);
	
					if(te instanceof TileEntityCore) {
						
						TileEntityCore core = (TileEntityCore)te;
						core.field += (int)(watts * lens.fieldMod);
						this.power -= (long)(demand * lens.drainMod);
						beam = i;
						
						long dmg = ItemLens.getLensDamage(inventory.getStackInSlot(0));
						dmg += watts;
						
						if(dmg >= lens.maxDamage)
							inventory.setStackInSlot(0, ItemStack.EMPTY);
						else
							ItemLens.setLensDamage(inventory.getStackInSlot(0), dmg);
						
						break;
					}

					if(te instanceof TileEntityCoreStabilizer)
						continue;
					
					if(world.getBlockState(pos1).getBlock() != Blocks.AIR)
						break;
				}
			}
			
			PacketDispatcher.wrapper.sendToAllTracking(new AuxGaugePacket(pos, beam, 0), new TargetPoint(world.provider.getDimension(), pos.getX(), pos.getY(), pos.getZ(), 250));
		}
	}

	@Override
	public void networkUnpack(NBTTagCompound data) {
		power = data.getLong("power");
		watts = data.getInteger("watts");
		isOn = data.getBoolean("isOn");
	}
	
	@Override
	public String getName() {
		return "container.dfcStabilizer";
	}

	public long getPowerScaled(long i) {
		return (power * i) / maxPower;
	}
	
	public int getWattsScaled(int i) {
		return (watts * i) / 100;
	}

	@Override
	public void setPower(long i) {
		this.power = i;
	}

	@Override
	public long getPower() {
		return this.power;
	}

	@Override
	public long getMaxPower() {
		return maxPower;
	}
	
	@Override
	public AxisAlignedBB getRenderBoundingBox() {
		return TileEntity.INFINITE_EXTENT_AABB;
	}
	
	@Override
	@SideOnly(Side.CLIENT)
	public double getMaxRenderDistanceSquared()
	{
		return 65536.0D;
	}
	
	@Override
	public void readFromNBT(NBTTagCompound compound) {
		power = compound.getLong("power");
		watts = compound.getInteger("watts");
		isOn = compound.getBoolean("isOn");
		super.readFromNBT(compound);
	}
	
	@Override
	public @NotNull NBTTagCompound writeToNBT(NBTTagCompound compound) {
		compound.setLong("power", power);
		compound.setInteger("watts", watts);
		compound.setBoolean("isOn", isOn);
		return super.writeToNBT(compound);
	}
}


maxdamage有问题，说错误引用,(),

<(),

现在暂时把cmd看内容先搞出来

package com._test_ddddddd_.dfcfix.command;//.debug;

import com.hbm.tileentity.machine.TileEntityCoreStabilizer;
import com.hbm.items.machine.ItemLens;
import net.minecraft.command.CommandBase;
import net.minecraft.command.ICommandSender;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;

import com._test_ddddddd_.dfcfix._lx_s_q_j_dddddddd_;

public class _cm_d_t_e_c_s_ddddddd_ extends CommandBase{//  extends CommandBase//.java//CommandCheckStabilizer extends CommandBase {

    @Override
    public String getName() {
        return "checkstabilizer"; //c t

                                  //大 类                                                                                                                                                                                                                                                                                                                                                                                                             小类    dddd,(),  ,(),
    }

    @Override
    public String getUsage(ICommandSender sender) {
        return "/checkstabilizer <x> <y> <z>"//;
            //+ "/dfcsetcore_2_ set_2_2_ <x> <y> <z> <heatCap:int>\n"//;

            + "/checkstabilizer_test_  <x> <y> <z>\n";// set_2_2_ <x> <y> <z> <heatCap:int>\n"


    }

    @Override
    public void execute(MinecraftServer server, ICommandSender sender, String[] args) {
        if(args.length != 3) {
            sender.sendMessage(getTextComponent("请提供坐标 x y z"));
            return;
        }

        try {
            int x = Integer.parseInt(args[0]);
            int y = Integer.parseInt(args[1]);
            int z = Integer.parseInt(args[2]);

            World world = sender.getEntityWorld();
            BlockPos pos = new BlockPos(x, y, z);
     ///////////////////////////////////////////////////////////////////////////////////////       if(world.getTileEntity(pos) instanceof TileEntityCoreStabilizer stabilizer) {

            if(world.getTileEntity(pos) instanceof TileEntityCoreStabilizer) {
                TileEntityCoreStabilizer stabilizer = (TileEntityCoreStabilizer) world.getTileEntity(pos);

                ItemStack stack = stabilizer.inventory.getStackInSlot(0);
                sender.sendMessage(getTextComponent("=== Core Stabilizer 信息 ==="));
                sender.sendMessage(getTextComponent("Power: " + stabilizer.getPower()));
                sender.sendMessage(getTextComponent("Watts: " + stabilizer.watts));
                sender.sendMessage(getTextComponent("Beam: " + stabilizer.beam));
                sender.sendMessage(getTextComponent("是否开启: " + stabilizer.isOn));

            //    // 调用外部调试类
          //      StabilizerDebug.logLens(stabilizer, sender);



                   


                _lx_s_q_j_dddddddd_.logLens(stabilizer, sender);//log_stabilizer, sender.//.java


///////////////////////////////////////////////////////////////////////////////////////////////////////////////                                                                                                       类原 没     查,(),                                                                                                                                           ,(),

                       //理论上不会失败，楼下闹尼玛,(),  ,(),



      //             import com._test_ddddddd_.dfcfix.debug.StabilizerDebug;
//import com.hbm.tileentity.machine.TileEntityCoreStabilizer;
//
//@Mixin(TileEntityCoreStabilizer.class)
//public abstract class TileEntityCoreStabilizerMixin {
//
  //  @Inject(method = "update", at = @At("HEAD"))
  //  private void beforeUpdate(CallbackInfo ci) {
 //       // 调用外部调试类
//        StabilizerDebug.logLens((TileEntityCoreStabilizer)(Object)this);
 //   }
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////}








                if(stack.isEmpty()) {
                    sender.sendMessage(getTextComponent("槽为空"));
                } else if(stack.getItem() instanceof ItemLens) {
                    ItemLens lens = (ItemLens) stack.getItem();//else if(stack.getItem() instanceof ItemLens lens) {





        //        else if(stack.getItem() instanceof ItemLens) {
                ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    ItemLens lens = (ItemLens) stack.getItem();
                    














                    if(stack.getTagCompound() == null)
                        stack.setTagCompound(new NBTTagCompound());

                    long dmg = ItemLens.getLensDamage(stack);
                    sender.sendMessage(getTextComponent("透镜: " + lens));
                    sender.sendMessage(getTextComponent("maxDamage: " + lens.maxDamage));
                    sender.sendMessage(getTextComponent("当前耐久: " + dmg));
                } else {
                    sender.sendMessage(getTextComponent("槽里的物品不是透镜: " + stack.getItem()));
                }

            } else {          //       闹尼玛        死全家,()<   ,(),        急尼玛，死全家，    再闹，       妈死了,()<         ,()<
                sender.sendMessage(getTextComponent("指定方块不是 Core Stabilizer"));
            }

        } catch(NumberFormatException e) {
            sender.sendMessage(getTextComponent("坐标必须是整数"));
        }
    }

    // 简化文本发送
    private net.minecraft.util.text.ITextComponent getTextComponent(String text) {
        return new net.minecraft.util.text.TextComponentString(text);
    }
}


//吵你妈，死全家,(),

//,(),


匹配下











package com._test_ddddddd_.dfcfix;           //.debug;

import com.hbm.tileentity.machine.TileEntityCoreStabilizer;
import com.hbm.items.machine.ItemLens;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;

public class _lx_s_q_j_dddddddd_{//.java//StabilizerDebug {

 ///////////////////////////////////////////////////////////////////////////////////   stabilizer v b,(), ,(),       s v ,(),             ,(),

    public static void logLens(TileEntityCoreStabilizer stabilizer) {
        ItemStack stack = stabilizer.inventory.getStackInSlot(0);

        if(stack == null || stack.isEmpty()) {
            System.out.println("[Debug] 槽为空");
            return;
        }

     //   if(stack.getItem() instanceof ItemLens lens) {


        if(stack.getItem() instanceof ItemLens) {
            ItemLens lens = (ItemLens) stack.getItem();
            // 这里继续使用 lens
/////////////////////////////////////////////////////////////////////}


            // 确保 NBT 初始化
            if(stack.getTagCompound() == null) {
                stack.setTagCompound(new NBTTagCompound());
                System.out.println("[Debug] NBT为空，已初始化");
            }

            long dmg = ItemLens.getLensDamage(stack);
            System.out.println("[Debug] 透镜: " + lens + ", maxDamage=" + lens.maxDamage + ", 当前耐久=" + dmg);

        } else {         //狗日的，      gsdsj,(),                                                                                                                                                               ,(),
            System.out.println("[Debug] 槽内不是透镜: " + stack.getItem());
        }
    }
}



ChatGPT 说：

我看了下你贴的三段代码，问题核心其实就是你说的 maxDamage 报错。原因很简单：

ItemLens 类本身里并没有一个公共字段叫 maxDamage。
Minecraft 原版 Item 提供的是方法 getMaxDamage()（返回一个 int），而不是字段。

所以在你 TileEntityCoreStabilizer 和调试类 _lx_s_q_j_dddddddd_ 里写的：

lens.maxDamage


这个引用会报错（错误引用）。正确写法是调用方法：

lens.getMaxDamage()


如果 ItemLens 是你们自己扩展的类、里面确实定义了 public int maxDamage; 字段，那就没问题，但从你代码看，更可能它是继承了 Item，那就必须用 getMaxDamage()。

比如这几处：

TileEntityCoreStabilizer.update()
if(dmg >= lens.maxDamage)
    inventory.setStackInSlot(0, ItemStack.EMPTY);


要改成：

if(dmg >= lens.getMaxDamage())
    inventory.setStackInSlot(0, ItemStack.EMPTY);

Command /checkstabilizer
sender.sendMessage(getTextComponent("maxDamage: " + lens.maxDamage));


要改成：

sender.sendMessage(getTextComponent("maxDamage: " + lens.getMaxDamage()));

_lx_s_q_j_dddddddd_.logLens
System.out.println("[Debug] 透镜: " + lens + ", maxDamage=" + lens.maxDamage + ", 当前耐久=" + dmg);


要改成：

System.out.println("[Debug] 透镜: " + lens + ", maxDamage=" + lens.getMaxDamage() + ", 当前耐久=" + dmg);


这样一改，就不会再报 “错误引用” 了。

要确认下：
你 ItemLens 里是自己写了 maxDamage 字段，还是完全继承 Item 用默认的耐久？

如果自己写了字段，那得确保是 public，或者提供 getter 方法。

如果没写字段，那就用 getMaxDamage()。

你要我帮你把三个类里相关地方都替换成 getMaxDamage() 吗？

您说：
Y:\新建文件夹 (857)\Hbm-s-Nuclear-Tech-GIT-Custom-1.12.2\src\main\java\com\hbm\items\ModItems.java

别人应该有set,反正我mixin后就出问题了,(),                          ,(),            

白痴，乱理解

还是智力低下

故意想让我充钱,()<

<(),

    - [warn]  Space-assignment syntax in Groovy DSL has been deprecated.:20
    - [warn]  Space-assignment syntax in Groovy DSL has been deprecated.:21
    - [warn]  Space-assignment syntax in Groovy DSL has been deprecated.:21
- :compileJava
    - [advice] Java compilation note:compileJava
    - [advice] Java compilation note:compileJava
    - [advice] Java compilation note:compileJava
    - [advice] Java compilation note:compileJava
    - [advice] Java compilation note:compileJava
    - [advice] Java compilation note:compileJava
    - [advice] Java compilation note:compileJava
    - [advice] Java compilation note:compileJava
    - [error] Java compilation error:compileJava
- Y:\新建文件夹 (278)\ForgeDevEnv-master\src\main\java\com\_test_ddddddd_\dfcfix\command\_cm_d_t_e_c_s_ddddddd_.java
    - [error] Java compilation error:68:36-8
无法将类 com._test_ddddddd_.dfcfix._lx_s_q_j_dddddddd_中的方法 logLens应用到给定类型;
  需要: com.hbm.tileentity.machine.TileEntityCoreStabilizer
  找到: com.hbm.tileentity.machine.TileEntityCoreStabilizer,net.minecraft.command.ICommandSender
  原因: 实际参数列表和形式参数列表长度不同
无法将类 com._test_ddddddd_.dfcfix._lx_s_q_j_dddddddd_中的方法 logLens应用到给定类型;
        - Solutions
        - Exception
ChatGPT 说：

现在报的这个错误，其实跟 maxDamage 没关系了，而是 方法签名不匹配。

编译器提示：

需要: com.hbm.tileentity.machine.TileEntityCoreStabilizer
找到: com.hbm.tileentity.machine.TileEntityCoreStabilizer,net.minecraft.command.ICommandSender
原因: 实际参数列表和形式参数列表长度不同


意思很直白：

你定义的 _lx_s_q_j_dddddddd_.logLens(...) 方法只接受 1 个参数：

public static void logLens(TileEntityCoreStabilizer stabilizer)


但你在命令里调用时传了 2 个参数：

_lx_s_q_j_dddddddd_.logLens(stabilizer, sender);


要解决，有两条路：

方案 A（简单粗暴，和现在的 logLens 保持一致）

只传一个参数：

_lx_s_q_j_dddddddd_.logLens(stabilizer);

方案 B（扩展 logLens，可以同时把消息发给命令执行者）

把 logLens 方法签名改掉，加上 ICommandSender 参数：

public static void logLens(TileEntityCoreStabilizer stabilizer, ICommandSender sender) {
    ItemStack stack = stabilizer.inventory.getStackInSlot(0);

    if(stack == null || stack.isEmpty()) {
        sender.sendMessage(new TextComponentString("[Debug] 槽为空"));
        return;
    }

    if(stack.getItem() instanceof ItemLens) {
        ItemLens lens = (ItemLens) stack.getItem();

        if(stack.getTagCompound() == null) {
            stack.setTagCompound(new NBTTagCompound());
            sender.sendMessage(new TextComponentString("[Debug] NBT为空，已初始化"));
        }

        long dmg = ItemLens.getLensDamage(stack);
        sender.sendMessage(new TextComponentString("[Debug] 透镜: " + lens
            + ", maxDamage=" + lens.getMaxDamage()
            + ", 当前耐久=" + dmg));
    } else {
        sender.sendMessage(new TextComponentString("[Debug] 槽内不是透镜: " + stack.getItem()));
    }
}


这样就能匹配你在命令里写的：

_lx_s_q_j_dddddddd_.logLens(stabilizer, sender);


所以问题很明确：你要么改 调用，要么改 方法定义，两个保持一致就没事。

要我帮你把 logLens 扩展成能发给 ICommandSender 的版本（方案 B）吗？

您说：
运行失败了，没加sender

 [FML.TEXTURE_ERRORS]:       textures/blocks/nuke_mike.png
[20:30:50] [Client thread/ERROR] [FML.TEXTURE_ERRORS]:       textures/blocks/machine_forcefield.png
[20:30:50] [Client thread/ERROR] [FML.TEXTURE_ERRORS]:       textures/blocks/machine_well.png
[20:30:50] [Client thread/ERROR] [FML.TEXTURE_ERRORS]:       textures/blocks/machine_fracking_tower.png
[20:30:50] [Client thread/ERROR] [FML.TEXTURE_ERRORS]:       textures/items/cc_plasma_gun.png
[20:30:50] [Client thread/ERROR] [FML.TEXTURE_ERRORS]:       textures/items/gun_brimstone.png
[20:30:50] [Client thread/ERROR] [FML.TEXTURE_ERRORS]: -------------------------
[20:30:50] [Client thread/ERROR] [FML.TEXTURE_ERRORS]:     The following other errors were reported for domain hbm:
[20:30:50] [Client thread/ERROR] [FML.TEXTURE_ERRORS]: -------------------------
[20:30:50] [Client thread/ERROR] [FML.TEXTURE_ERRORS]:     Problem: broken aspect ratio and not an animation
[20:30:50] [Client thread/ERROR] [FML.TEXTURE_ERRORS]:       textures/models/machines/demon_lamp.png
[20:30:50] [Client thread/ERROR] [FML.TEXTURE_ERRORS]: ==================================================
[20:30:50] [Client thread/ERROR] [FML.TEXTURE_ERRORS]: +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=
[20:30:51] [Realms Notification Availability checker #1/INFO] [mojang/RealmsClient]: Could not authorize you against Realms server: java.lang.RuntimeException: Failed to parse into SignedJWT: 0
[20:30:56] [Server thread/INFO] [minecraft/IntegratedServer]: Starting integrated minecraft server version 1.12.2
[20:30:56] [Server thread/INFO] [minecraft/IntegratedServer]: Generating keypair
[20:30:56] [Server thread/INFO] [FML]: Injecting existing registry data into this server instance
[20:30:57] [Server thread/INFO] [FML]: Applying holder lookups
[20:30:57] [Server thread/INFO] [FML]: Holder lookups applied
[20:30:57] [Server thread/INFO] [FML]: Loading dimension 0 (鏂扮殑涓栫晫) (net.minecraft.server.integrated.IntegratedServer@5005e82b)
[20:30:57] [Server thread/INFO] [minecraft/AdvancementList]: Loaded 573 advancements
[20:30:57] [Server thread/INFO] [FML]: Loading dimension -1 (鏂扮殑涓栫晫) (net.minecraft.server.integrated.IntegratedServer@5005e82b)
[20:30:57] [Server thread/INFO] [FML]: Loading dimension 1 (鏂扮殑涓栫晫) (net.minecraft.server.integrated.IntegratedServer@5005e82b)
[20:30:57] [Server thread/INFO] [minecraft/MinecraftServer]: Preparing start region for level 0
[20:30:58] [Server thread/INFO] [STDOUT]: [com._test_ddddddd_.dfcfix.command.c_d_s_c_ddddddddddddd_ddddddddddddddddddddd_:<init>:66]: [DFC] CommandDfcSetCore_2_ constructed
[20:30:58] [Server thread/INFO] [FML]: Unloading dimension -1
[20:30:58] [Server thread/INFO] [FML]: Unloading dimension 1
[20:30:58] [Server thread/INFO] [minecraft/IntegratedServer]: Changing view distance to 12, from 10
[20:31:10] [Netty Local Client IO #0/INFO] [FML]: Server protocol version 2
[20:31:10] [Netty Server IO #1/INFO] [FML]: Client protocol version 2
[20:31:10] [Netty Server IO #1/INFO] [FML]: Client attempting to join with 8 mods : minecraft@1.12.2,nbtedit@$version,hbm@NTM-Extended-1.12.2-2.0.2,FML@8.0.99.99,dfcfix@1.0,forge@14.23.5.2847,mixinbooter@10.2,mcp@9.42
[20:31:10] [Netty Local Client IO #0/INFO] [FML]: [Netty Local Client IO #0] Client side modded connection established
[20:31:10] [Server thread/INFO] [FML]: [Server thread] Server side modded connection established
[20:31:10] [Server thread/INFO] [minecraft/PlayerList]: Developer[local:E:6c7f7343] logged in with entity id 320 at (221.38218721079957, 70.0, 165.03531295006727)
[20:31:10] [Server thread/INFO] [minecraft/MinecraftServer]: Developer鍔犲叆浜嗘父鎴?
<[20:31:11] [Server thread/INFO] [minecraft/IntegratedServer]: Saving and pausing game...
[20:31:11] [Server thread/INFO] [minecraft/MinecraftServer]: Saving chunks for level '鏂扮殑涓栫晫'/overworld
[20:31:12] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] 娆㈣繋鍥炴潵
[20:31:15] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] 鏈煡鍛戒护銆傝浣跨敤/help鏉ユ煡鐪嬪懡浠ゅ垪琛ㄣ€?
<[20:31:18] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] /checkstabilizer, /clear, /clone
[20:31:26] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] /?, /advancement, /blockdata, /checkstabilizer, /clear, /clone, /debug, /defaultgamemode, /dfccore, /dfccore_2_, /dfcfix, /dfcset, /dfcset_2_, /dfcsetcore, /dfcsetcore_2_, /difficulty, /effect, /enchant, /entitydata, /execute, /fill, /forge, /function, /gamemode, /gamerule, /give, /hbm, /hbmrad, /help, /kill, /locate, /me, /msg, /nbtedit, /particle, /playsound, /publish, /recipe, /reload, /replaceitem, /say, /scoreboard, /seed, /setblock, /setworldspawn, /spawnpoint, /spreadplayers, /stats, /stopsound, /summon, /teleport, /tell, /tellraw, /testfor, /testforblock, /testforblocks, /time, /title, /toggledownfall, /tp, /trigger, /w, /weather, /worldborder, /xp
[20:31:28] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] /checkstabilizer, /clear, /clone
[20:31:36] [Server thread/WARN] [minecraft/CommandHandler]: Couldn't process command: checkstabilizer 220 70 162
java.lang.NoSuchFieldError: maxDamage
        at com._test_ddddddd_.dfcfix._lx_s_q_j_dddddddd_.logLens(_lx_s_q_j_dddddddd_.java:46) ~[_lx_s_q_j_dddddddd_.class:?]
        at com._test_ddddddd_.dfcfix.command._cm_d_t_e_c_s_ddddddd_.execute(_cm_d_t_e_c_s_ddddddd_.java:68) ~[_cm_d_t_e_c_s_ddddddd_.class:?]
        at net.minecraft.command.CommandHandler.tryExecute(CommandHandler.java:124) [CommandHandler.class:?]
        at net.minecraft.command.CommandHandler.executeCommand(CommandHandler.java:96) [CommandHandler.class:?]
        at net.minecraft.network.NetHandlerPlayServer.handleSlashCommand(NetHandlerPlayServer.java:1005) [NetHandlerPlayServer.class:?]
        at net.minecraft.network.NetHandlerPlayServer.processChatMessage(NetHandlerPlayServer.java:981) [NetHandlerPlayServer.class:?]
        at net.minecraft.network.play.client.CPacketChatMessage.processPacket(CPacketChatMessage.java:47) [CPacketChatMessage.class:?]
        at net.minecraft.network.play.client.CPacketChatMessage.processPacket(CPacketChatMessage.java:8) [CPacketChatMessage.class:?]
        at net.minecraft.network.PacketThreadUtil$1.run(PacketThreadUtil.java:15) [PacketThreadUtil$1.class:?]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [?:1.8.0_462]
        at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_462]
        at net.minecraft.util.Util.runTask(Util.java:50) [Util.class:?]
        at net.minecraft.server.MinecraftServer.updateTimeLightAndEntities(MinecraftServer.java:797) [MinecraftServer.class:?]
        at net.minecraft.server.MinecraftServer.tick(MinecraftServer.java:742) [MinecraftServer.class:?]
        at net.minecraft.server.integrated.IntegratedServer.tick(IntegratedServer.java:192) [IntegratedServer.class:?]
        at net.minecraft.server.MinecraftServer.run(MinecraftServer.java:591) [MinecraftServer.class:?]
        at java.lang.Thread.run(Thread.java:750) [?:1.8.0_462]
[20:31:36] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] === Core Stabilizer 淇℃伅 ===
[20:31:36] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] Power: 10000000000000
[20:31:36] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] Watts: 98
[20:31:36] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] Beam: 0
[20:31:36] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] 鏄惁寮€鍚? true
[20:31:36] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] 鍦ㄦ墽琛屾鍛戒护鏃跺嚭鐜颁簡鏈煡鐨勯敊璇?
<=[20:31:47] [Server thread/INFO] [minecraft/IntegratedServer]: Saving and pausing game...
[20:31:47] [Server thread/INFO] [minecraft/MinecraftServer]: Saving chunks for level '鏂扮殑涓栫晫'/overworld
<============-> 97% EXECUTING [4m 24s]
> :runClient
ChatGPT 说：

这个报错就说明问题彻底确认了：

java.lang.NoSuchFieldError: maxDamage


你在运行时访问了 lens.maxDamage，但实际的 ItemLens 类里根本没有这个字段。编译时可能因为 ItemLens 里声明过（或者 Mixin 改过）还能过，但运行时加载的 真正 class 没这个字段，所以直接炸。

在 Minecraft 1.12.2 里，Item 体系只有 方法：

public int getMaxDamage(ItemStack stack)


或者

public int getMaxDamage()


没有 public int maxDamage; 这种字段。

所以要把所有地方的 lens.maxDamage 全换掉，比如：

_lx_s_q_j_dddddddd_.logLens
System.out.println("[Debug] 透镜: " + lens
    + ", maxDamage=" + lens.getMaxDamage()
    + ", 当前耐久=" + dmg);

/checkstabilizer 命令
sender.sendMessage(getTextComponent("maxDamage: " + lens.getMaxDamage()));

TileEntityCoreStabilizer.update()
if(dmg >= lens.getMaxDamage())
    inventory.setStackInSlot(0, ItemStack.EMPTY);


🔑 总结：

不要用 lens.maxDamage，这是个不存在的字段。

正确用 lens.getMaxDamage() 或 stack.getMaxDamage()。

这样就不会再报 NoSuchFieldError。

要我帮你把三个文件里所有 maxDamage 的地方都替换成 getMaxDamage()，写出完整修改后的代码吗？

您说：
不是，重点是你知道函数调用成功没
ChatGPT 说：

我明白了，你要确认的其实不是“写法对不对”，而是 logLens(...) 这个函数调用到底有没有被执行成功。

从你贴的报错信息来看：

无法将类 com._test_ddddddd_.dfcfix._lx_s_q_j_dddddddd_中的方法 logLens应用到给定类型;
需要: com.hbm.tileentity.machine.TileEntityCoreStabilizer
找到: com.hbm.tileentity.machine.TileEntityCoreStabilizer, net.minecraft.command.ICommandSender
原因: 实际参数列表和形式参数列表长度不同


这说明——编译阶段根本没通过。也就是说：

调用 logLens(...) 时，你传入了两个参数（TileEntityCoreStabilizer, ICommandSender）。

但函数的定义只接收一个参数（TileEntityCoreStabilizer）。

所以编译器直接报错了，压根没生成字节码，也就不可能在运行时被调用。

换句话说：
✔️ 函数调用没有成功，连编译都没过。

要验证它有没有真正跑起来，你需要保证方法签名和调用参数一致，然后再在 logLens 里加一个最简单的标记：

public static void logLens(TileEntityCoreStabilizer te) {
    System.out.println("[logLens] called, te=" + te);
    ...
}


这样如果游戏启动后你在控制台里看见 [logLens] called...，就能确认调用确实成功进入了。

要不要我帮你对照一下你 logLens 的方法签名和 /checkstabilizer 命令里调用的地方，把它们调成一致？

您说：
java有没有发生error但不退出，类似py try
ChatGPT 说：

有的，Java 里也有跟 Python try/except 类似的东西，就是 try { ... } catch (...) { ... }。区别是：

如果你不 catch → 一旦抛出异常（error/exception），就会一路冒泡，最终没处理就崩溃退出（比如你遇到的 NoSuchFieldError）。

如果你 catch 了 → 那段代码报错后会跳进 catch 里执行，但程序不会退出，后面的代码还能继续跑。

最基本的写法：

try {
    // 可能会报错的代码
    int x = 1 / 0;  // 除零错误
} catch (Exception e) {
    // 这里相当于 Python 的 except
    e.printStackTrace();  // 打印堆栈，不影响后续运行
}

System.out.println("还能继续跑");


控制台输出：

java.lang.ArithmeticException: / by zero
    at Test.main(Test.java:5)
还能继续跑


要注意几个点：

Java 区分 Exception 和 Error。

一般用 catch (Exception e) 就能兜大部分运行时错误。

但像你之前遇到的 NoSuchFieldError 属于 Error（更底层，通常意味着代码/类定义有问题），要想拦住要写 catch (Throwable t)。

catch (Throwable t) 虽然能兜一切（包括 Exception 和 Error），但这在正式代码里通常不推荐，因为可能掩盖严重问题。

如果只是做调试/容错，你可以先写：

try {
    // risky
} catch (Throwable t) {
    t.printStackTrace();
}


这样就能保证“不退出”。

要不要我帮你把你那个 logLens 调用包一层 try/catch，这样即使它再报错也不会导致整个命令崩？

您说：
[Client thread/ERROR] [FML.TEXTURE_ERRORS]:       textures/blocks/nuke_mike.png
[20:51:06] [Client thread/ERROR] [FML.TEXTURE_ERRORS]:       textures/blocks/machine_forcefield.png
[20:51:06] [Client thread/ERROR] [FML.TEXTURE_ERRORS]:       textures/blocks/machine_well.png
[20:51:06] [Client thread/ERROR] [FML.TEXTURE_ERRORS]:       textures/blocks/machine_fracking_tower.png
[20:51:06] [Client thread/ERROR] [FML.TEXTURE_ERRORS]:       textures/items/cc_plasma_gun.png
[20:51:06] [Client thread/ERROR] [FML.TEXTURE_ERRORS]:       textures/items/gun_brimstone.png
[20:51:06] [Client thread/ERROR] [FML.TEXTURE_ERRORS]: -------------------------
[20:51:06] [Client thread/ERROR] [FML.TEXTURE_ERRORS]:     The following other errors were reported for domain hbm:
[20:51:06] [Client thread/ERROR] [FML.TEXTURE_ERRORS]: -------------------------
[20:51:06] [Client thread/ERROR] [FML.TEXTURE_ERRORS]:     Problem: broken aspect ratio and not an animation
[20:51:06] [Client thread/ERROR] [FML.TEXTURE_ERRORS]:       textures/models/machines/demon_lamp.png
[20:51:06] [Client thread/ERROR] [FML.TEXTURE_ERRORS]: ==================================================
[20:51:06] [Client thread/ERROR] [FML.TEXTURE_ERRORS]: +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=
[20:51:07] [Realms Notification Availability checker #1/INFO] [mojang/RealmsClient]: Could not authorize you against Realms server: java.lang.RuntimeException: Failed to parse into SignedJWT: 0
[20:51:10] [Server thread/INFO] [minecraft/IntegratedServer]: Starting integrated minecraft server version 1.12.2
[20:51:10] [Server thread/INFO] [minecraft/IntegratedServer]: Generating keypair
[20:51:10] [Server thread/INFO] [FML]: Injecting existing registry data into this server instance
[20:51:11] [Server thread/INFO] [FML]: Applying holder lookups
[20:51:11] [Server thread/INFO] [FML]: Holder lookups applied
[20:51:11] [Server thread/INFO] [FML]: Loading dimension 0 (鏂扮殑涓栫晫) (net.minecraft.server.integrated.IntegratedServer@22b61ed5)
[20:51:11] [Server thread/INFO] [minecraft/AdvancementList]: Loaded 573 advancements
[20:51:11] [Server thread/INFO] [FML]: Loading dimension -1 (鏂扮殑涓栫晫) (net.minecraft.server.integrated.IntegratedServer@22b61ed5)
[20:51:11] [Server thread/INFO] [FML]: Loading dimension 1 (鏂扮殑涓栫晫) (net.minecraft.server.integrated.IntegratedServer@22b61ed5)
[20:51:11] [Server thread/INFO] [minecraft/MinecraftServer]: Preparing start region for level 0
[20:51:12] [Server thread/INFO] [STDOUT]: [com._test_ddddddd_.dfcfix.command.c_d_s_c_ddddddddddddd_ddddddddddddddddddddd_:<init>:66]: [DFC] CommandDfcSetCore_2_ constructed
[20:51:12] [Server thread/INFO] [FML]: Unloading dimension -1
[20:51:12] [Server thread/INFO] [FML]: Unloading dimension 1
[20:51:12] [Server thread/INFO] [minecraft/IntegratedServer]: Changing view distance to 12, from 10
[20:51:24] [Netty Local Client IO #0/INFO] [FML]: Server protocol version 2
[20:51:24] [Netty Server IO #1/INFO] [FML]: Client protocol version 2
[20:51:24] [Netty Server IO #1/INFO] [FML]: Client attempting to join with 8 mods : minecraft@1.12.2,nbtedit@$version,hbm@NTM-Extended-1.12.2-2.0.2,FML@8.0.99.99,dfcfix@1.0,forge@14.23.5.2847,mixinbooter@10.2,mcp@9.42
[20:51:24] [Netty Local Client IO #0/INFO] [FML]: [Netty Local Client IO #0] Client side modded connection established
[20:51:24] [Server thread/INFO] [FML]: [Server thread] Server side modded connection established
[20:51:24] [Server thread/INFO] [minecraft/PlayerList]: Developer[local:E:bdd8003e] logged in with entity id 335 at (221.77392135961483, 70.0, 165.33557975069112)
[20:51:24] [Server thread/INFO] [minecraft/MinecraftServer]: Developer鍔犲叆浜嗘父鎴?
<[20:51:25] [Server thread/INFO] [minecraft/IntegratedServer]: Saving and pausing game...
[20:51:25] [Server thread/INFO] [minecraft/MinecraftServer]: Saving chunks for level '鏂扮殑涓栫晫'/overworld
[20:51:25] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] 娆㈣繋鍥炴潵
[20:51:33] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] /checkstabilizer, /clear, /clone
[20:51:40] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] === Core Stabilizer 淇℃伅 ===
[20:51:40] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] Power: 10000000000000
[20:51:40] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] Watts: 98
[20:51:40] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] Beam: 0
[20:51:40] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] 鏄惁寮€鍚? true
[20:51:40] [Server thread/INFO] [STDOUT]: [com._test_ddddddd_.dfcfix._lx_s_q_j_dddddddd_:logLens:24]: [logLens] called, s_=com.hbm.tileentity.machine.TileEntityCoreStabilizer@2f972674
[20:51:40] [Server thread/WARN] [minecraft/CommandHandler]: Couldn't process command: checkstabilizer 220 70 162
java.lang.NoSuchFieldError: maxDamage
        at com._test_ddddddd_.dfcfix._lx_s_q_j_dddddddd_.logLens(_lx_s_q_j_dddddddd_.java:49) ~[_lx_s_q_j_dddddddd_.class:?]
        at com._test_ddddddd_.dfcfix.command._cm_d_t_e_c_s_ddddddd_.execute(_cm_d_t_e_c_s_ddddddd_.java:74) ~[_cm_d_t_e_c_s_ddddddd_.class:?]
        at net.minecraft.command.CommandHandler.tryExecute(CommandHandler.java:124) [CommandHandler.class:?]
        at net.minecraft.command.CommandHandler.executeCommand(CommandHandler.java:96) [CommandHandler.class:?]
        at net.minecraft.network.NetHandlerPlayServer.handleSlashCommand(NetHandlerPlayServer.java:1005) [NetHandlerPlayServer.class:?]
        at net.minecraft.network.NetHandlerPlayServer.processChatMessage(NetHandlerPlayServer.java:981) [NetHandlerPlayServer.class:?]
        at net.minecraft.network.play.client.CPacketChatMessage.processPacket(CPacketChatMessage.java:47) [CPacketChatMessage.class:??]
        at net.minecraft.network.play.client.CPacketChatMessage.processPacket(CPacketChatMessage.java:8) [CPacketChatMessage.class:?]
        at net.minecraft.network.PacketThreadUtil$1.run(PacketThreadUtil.java:15) [PacketThreadUtil$1.class:?]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [?:1.8.0_462]
        at java.util.concurrent.FutureTask.run(FutureTask.java:266) [?:1.8.0_462]
        at net.minecraft.util.Util.runTask(Util.java:50) [Util.class:?]
        at net.minecraft.server.MinecraftServer.updateTimeLightAndEntities(MinecraftServer.java:797) [MinecraftServer.class:?]
        at net.minecraft.server.MinecraftServer.tick(MinecraftServer.java:742) [MinecraftServer.class:?]
        at net.minecraft.server.integrated.IntegratedServer.tick(IntegratedServer.java:192) [IntegratedServer.class:?]
        at net.minecraft.server.MinecraftServer.run(MinecraftServer.java:591) [MinecraftServer.class:?]
<============-> 97% EXECUTING [1m 34s].java:750) [?:1.8.0_462]
[20:51:40] [Client thread/INFO] [minecraft/GuiNewChat]: [CHAT] 鍦ㄦ墽琛屾鍛戒护鏃跺嚭鐜颁簡鏈煡鐨勯敊璇?
<[20:51:43] [Server thread/INFO] [minecraft/IntegratedServer]: Saving and pausing game...
[20:51:43] [Server thread/INFO] [minecraft/MinecraftServer]: Saving chunks for level '鏂扮殑涓栫晫'/overworld
<============-> 97% EXECUTING [1m 31s]
> :runClient
ChatGPT 说：

看日志就能确认两件事：

调用确实成功了

[Server thread/INFO] [STDOUT]: [com._test_ddddddd_.dfcfix._lx_s_q_j_dddddddd_:logLens:24]: [logLens] called, s_=com.hbm.tileentity.machine.TileEntityCoreStabilizer@2f972674


这说明 logLens(...) 方法被调用进去了，你写的 System.out.println("[logLens] called...") 打印出来了。

在方法内部抛出了异常

java.lang.NoSuchFieldError: maxDamage
    at com._test_ddddddd_.dfcfix._lx_s_q_j_dddddddd_.logLens(_lx_s_q_j_dddddddd_.java:49)


表明执行到 lens.maxDamage 时崩了，因为运行时根本没有这个字段。

所以状态是：

方法签名匹配，调用成功。

进入方法后，在访问 maxDamage 时抛错 → 命令执行被中断，FML 捕获并在聊天框显示“出现未知错误”。

如果你想确认调用，但不让整个命令失败，可以在 logLens 里包一层：

public static void logLens(TileEntityCoreStabilizer te) {
    try {
        System.out.println("[logLens] called, s_=" + te);

        // 这里访问 lens
        ItemStack lens = te.inventory.getStackInSlot(0);
        if (!lens.isEmpty()) {
            System.out.println("maxDamage=" + lens.getItem().getMaxDamage(lens));
        }

    } catch (Throwable t) {
        System.out.println("[logLens] error: " + t.getClass().getName() + " - " + t.getMessage());
        t.printStackTrace();
    }
}


这样：

你还能看到 [logLens] called，证明方法执行了。

即使里面报错，也不会把 /checkstabilizer 命令整体打断。

要不要我帮你直接改成安全版本（全用 getMaxDamage，再加 try/catch），这样你下次执行命令就能跑完而不是掉到“未知错误”？

您说：
hbm这么引用的，你改不了,

                                可能是什么原因导致的，现在注入是改燃料大小，可能就是mixin,core变了导致的问题

                             package com.hbm.tileentity.machine;

import java.util.List;

import com.hbm.entity.effect.EntityCloudFleijaRainbow;
import com.hbm.entity.logic.EntityNukeExplosionMK3;
import com.hbm.forgefluid.FFUtils;
import com.hbm.forgefluid.FluidTypeHandler;
import com.hbm.forgefluid.ModForgeFluids;
import com.hbm.handler.ArmorUtil;
import com.hbm.items.ModItems;
import com.hbm.items.machine.ItemCatalyst;
import com.hbm.items.special.ItemAMSCore;
import com.hbm.lib.Library;
import com.hbm.lib.ModDamageSource;
import com.hbm.main.AdvancementManager;
import com.hbm.tileentity.TileEntityMachineBase;

import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.SoundEvents;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.ITickable;
import net.minecraft.util.SoundCategory;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraftforge.fluids.Fluid;
import net.minecraftforge.fluids.FluidRegistry;
import net.minecraftforge.fluids.FluidStack;
import net.minecraftforge.fluids.FluidTank;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.jetbrains.annotations.NotNull;

public class TileEntityCore extends TileEntityMachineBase implements ITickable {

	public boolean hasCore = false;
	public int field;
	public int heat;
	public int color;
	public FluidTank[] tanks;
	public int safeTimer = 0;
	
	public TileEntityCore() {
		super(3);
		tanks = new FluidTank[2];
		tanks[0] = new FluidTank(128000);
		tanks[1] = new FluidTank(128000);
	}

	@Override
	public String getName() {
		return "container.dfcCore";
	}

	@Override
	public void update() {
		if(!world.isRemote) {
			if(heat > 0 && heat >= field) {
				if(safeTimer > 20){
					int fill = tanks[0].getFluidAmount() + tanks[1].getFluidAmount();
					int max = tanks[0].getCapacity() + tanks[1].getCapacity();
					int mod = heat * 10;
					
					int size = Math.max(Math.min(fill * mod / max, 1000), 50);
					
					//System.out.println(fill + " * " + mod + " / " + max + " = " + size);

		    		world.playSound(null, pos.getX(), pos.getY(), pos.getZ(), SoundEvents.ENTITY_GENERIC_EXPLODE, SoundCategory.BLOCKS, 100000.0F, 1.0F);

					EntityNukeExplosionMK3 exp = new EntityNukeExplosionMK3(world);
					exp.posX = pos.getX();
					exp.posY = pos.getY();
					exp.posZ = pos.getZ();
					exp.destructionRange = size;
					exp.speed = 25;
					exp.coefficient = 1.0F;
					exp.waste = false;
				
					if(safeTimer > 1200 || !EntityNukeExplosionMK3.isJammed(this.world, exp)){
						world.spawnEntity(exp);
			    		
			    		EntityCloudFleijaRainbow cloud = new EntityCloudFleijaRainbow(world, size);
			    		cloud.posX = pos.getX();
			    		cloud.posY = pos.getY();
			    		cloud.posZ = pos.getZ();
			    		world.spawnEntity(cloud);
			    		world.setBlockToAir(pos);
			    	}
		    	}
		    	safeTimer++;
			} else {
				if(safeTimer > 0) safeTimer--;
			}
			
			if(inventory.getStackInSlot(0).getItem() instanceof ItemCatalyst && inventory.getStackInSlot(2).getItem() instanceof ItemCatalyst){
				color = calcAvgHex(
						((ItemCatalyst)inventory.getStackInSlot(0).getItem()).getColor(),
						((ItemCatalyst)inventory.getStackInSlot(2).getItem()).getColor()
				);
				hasCore = true;
			}else{
				color = 0;
				hasCore = false;
			}
			
			if(heat > 0){
				radiation();
			}
			
			NBTTagCompound data = new NBTTagCompound();
			data.setString("tank0", tanks[0].getFluid() == null ? "HBM_EMPTY" : tanks[0].getFluid().getFluid().getName());
			data.setString("tank1", tanks[1].getFluid() == null ? "HBM_EMPTY" : tanks[1].getFluid().getFluid().getName());
			data.setInteger("fill0", tanks[0].getFluidAmount());
			data.setInteger("fill1", tanks[1].getFluidAmount());
			data.setInteger("field", field);
			data.setInteger("heat", heat);
			data.setInteger("color", color);
			data.setBoolean("hasCore", hasCore);
			networkPack(data, 250);
			
			//PacketDispatcher.wrapper.sendToAllAround(new FluidTankPacket(pos, tanks), new TargetPoint(world.provider.getDimension(), pos.getX(), pos.getY(), pos.getZ(), 10));
			
			heat = 0;
			field = 0;
			this.markDirty();
		} else {
			
			//TODO: sick particle effects
		}
	}
	
	@Override
	public void networkUnpack(NBTTagCompound data) {
		String s0 = data.getString("tank0");
		String s1 = data.getString("tank1");
		if("HBM_EMPTY".equals(s0)){
			tanks[0].setFluid(null);
		} else {
			tanks[0].setFluid(new FluidStack(FluidRegistry.getFluid(s0), data.getInteger("fill0")));
		}
		if("HBM_EMPTY".equals(s1)){
			tanks[1].setFluid(null);
		} else {
			tanks[1].setFluid(new FluidStack(FluidRegistry.getFluid(s1), data.getInteger("fill1")));
		}
		field = data.getInteger("field");
		heat = data.getInteger("heat");
		color = data.getInteger("color");
		hasCore = data.getBoolean("hasCore");
	}
	
	private void radiation() {
		
		double scale = (int)Math.log(heat) * 1.25 + 0.5;
		
		int range = (int)(scale * 4);
		List<Entity> list = world.getEntitiesWithinAABBExcludingEntity(null, new AxisAlignedBB(pos.getX() - range + 0.5, pos.getY() - range + 0.5, pos.getZ() - range + 0.5, pos.getX() + range + 0.5, pos.getY() + range + 0.5, pos.getZ() + range + 0.5));
		
		for(Entity e : list) {
			boolean isPlayer = e instanceof EntityPlayer;
			if(!(isPlayer && ArmorUtil.checkForHazmat((EntityPlayer)e))){
				if(!(Library.isObstructed(world, pos.getX() + 0.5, pos.getY() + 0.5 + 6, pos.getZ() + 0.5, e.posX, e.posY + e.getEyeHeight(), e.posZ))){
					if(!isPlayer || (isPlayer && !((EntityPlayer)e).capabilities.isCreativeMode))
						e.attackEntityFrom(ModDamageSource.ams, this.heat * 100);
					e.setFire(3);
				}
			}
			if(isPlayer){
				AdvancementManager.grantAchievement(((EntityPlayer) e), AdvancementManager.progress_dfc);
			}
		}

		List<Entity> list2 = world.getEntitiesWithinAABBExcludingEntity(null, new AxisAlignedBB(pos.getX() - scale + 0.5, pos.getY() - scale + 0.5, pos.getZ() - scale + 0.5, pos.getX() + scale + 0.5, pos.getY() + scale + 0.5, pos.getZ() + scale + 0.5));
		
		for(Entity e : list2) {
			boolean isPlayer = e instanceof EntityPlayer;
			if(!(isPlayer && ArmorUtil.checkForHaz2((EntityPlayer)e))){
				if(!isPlayer || (isPlayer && !((EntityPlayer)e).capabilities.isCreativeMode))
					e.attackEntityFrom(ModDamageSource.amsCore, this.heat * 1000);
				e.setFire(3);
			}
		}
	}
	
	public int getFieldScaled(int i) {
		return (field * i) / 100;
	}
	
	public int getHeatScaled(int i) {
		return (heat * i) / 100;
	}
	
	public boolean isReady() {
		
		if(getCorePower() == 0)
			return false;
		
		if(color == 0)
			return false;
		
		if(tanks[0].getFluid() == null || tanks[1].getFluid() == null)
			return false;
		
		if(FluidTypeHandler.getDFCEfficiency(tanks[0].getFluid().getFluid()) <= 0 || FluidTypeHandler.getDFCEfficiency(tanks[1].getFluid().getFluid()) <= 0)
			return false;
		
		return true;
	}
	
	//100 emitter watt = 10000 joules = 1 heat = 10mB burned
	public long burn(long joules) {
		
		//check if a reaction can take place
		if(!isReady())
			return joules;
		
		int demand = (int)Math.sqrt((double)joules);

		long powerAbs = ItemCatalyst.getPowerAbs(inventory.getStackInSlot(0)) + ItemCatalyst.getPowerAbs(inventory.getStackInSlot(2));
		float powerMod = ItemCatalyst.getPowerMod(inventory.getStackInSlot(0)) * ItemCatalyst.getPowerMod(inventory.getStackInSlot(2));
		float heatMod = ItemCatalyst.getHeatMod(inventory.getStackInSlot(0)) * ItemCatalyst.getHeatMod(inventory.getStackInSlot(2));
		float fuelMod = ItemCatalyst.getFuelMod(inventory.getStackInSlot(0)) * ItemCatalyst.getFuelMod(inventory.getStackInSlot(2));	

		demand = (int)(getCoreFuel() * demand * fuelMod);
		
		//check if the reaction has enough valid fuel
		if(tanks[0].getFluidAmount() < demand || tanks[1].getFluidAmount() < demand)
			return joules;
		
		heat += (int)(getCoreHeat() * heatMod * Math.ceil((double)joules / 10000D));
		
		Fluid f1 = tanks[0].getFluid().getFluid();
		Fluid f2 = tanks[1].getFluid().getFluid();

		tanks[0].drain(demand, true);
		tanks[1].drain(demand, true);

		long powerOutput = (long) Math.max(0, (powerMod * joules * getCorePower() * FluidTypeHandler.getDFCEfficiency(f1) * FluidTypeHandler.getDFCEfficiency(f2)) + powerAbs);
		if(powerOutput > 0 && heat == 0)
			heat = 1;
		return powerOutput;
	}
	
	//TODO: move stats to the AMSCORE class
	//Alcater: ok did that
	public int getCorePower() {
		return ItemAMSCore.getPowerBase(inventory.getStackInSlot(1));
	}

	public float getCoreHeat() {
		return ItemAMSCore.getHeatBase(inventory.getStackInSlot(1));
	}

	public float getCoreFuel() {
		return ItemAMSCore.getFuelBase(inventory.getStackInSlot(1));
	}
	
	private int calcAvgHex(int h1, int h2) {

		int r1 = ((h1 & 0xFF0000) >> 16);
		int g1 = ((h1 & 0x00FF00) >> 8);
		int b1 = ((h1 & 0x0000FF) >> 0);
		
		int r2 = ((h2 & 0xFF0000) >> 16);
		int g2 = ((h2 & 0x00FF00) >> 8);
		int b2 = ((h2 & 0x0000FF) >> 0);

		int r = (((r1 + r2) / 2) << 16);
		int g = (((g1 + g2) / 2) << 8);
		int b = (((b1 + b2) / 2) << 0);
		
		return r | g | b;
	}
	
	@Override
	public AxisAlignedBB getRenderBoundingBox() {
		return TileEntity.INFINITE_EXTENT_AABB;
	}
	
	@Override
	@SideOnly(Side.CLIENT)
	public double getMaxRenderDistanceSquared()
	{
		return 65536.0D;
	}
	
	@Override
	public void readFromNBT(NBTTagCompound compound) {
		if(compound.hasKey("tanks"))
			FFUtils.deserializeTankArray(compound.getTagList("tanks", 10), tanks);
		super.readFromNBT(compound);
	}
	
	@Override
	public @NotNull NBTTagCompound writeToNBT(NBTTagCompound compound) {
		compound.setTag("tanks", FFUtils.serializeTankArray(tanks));
		return super.writeToNBT(compound);
	}
}




						long dmg = ItemLens.getLensDamage(inventory.getStackInSlot(0));
						dmg += watts;
						
						if(dmg >= lens.maxDamage)
							inventory.setStackInSlot(0, ItemStack.EMPTY);
						else
							ItemLens.setLensDamage(inventory.getStackInSlot(0), dmg);
						
						break;
					}

明明有get,你一直乱讲
ChatGPT 说：

我看到问题的关键了：

在你贴的代码里，Hbm 的 源码里确实是这样写的：

if (dmg >= lens.maxDamage)
    inventory.setStackInSlot(0, ItemStack.EMPTY);
else
    ItemLens.setLensDamage(inventory.getStackInSlot(0), dmg);


这里访问的是 lens.maxDamage 字段。这在 原版 Minecraft 1.12.2 的 Item 类里是存在的（public int maxDamage;）。

但是你报错的堆栈是：

java.lang.NoSuchFieldError: maxDamage
    at com._test_ddddddd_.dfcfix._lx_s_q_j_dddddddd_.logLens(...)


说明运行时找不到这个字段。

这意味着：

编译期和运行期用的 Item 类不一致

你编译时引用的是 原版 MCP/Mojang 映射下的 Item，它有 maxDamage 字段。

运行时，Mixin/核心改动过的 Forge/Hbm 环境里，Item 的字段名可能已经被 移除或改名。

Mixin/核心模组把 Item 的访问改掉了

很可能 Hbm 或你自己的 mixin 修改里，把 maxDamage 替换成了 getMaxDamage(ItemStack) 这种方法。

所以原来能直接访问的字段，现在要通过 getter。

NoSuchFieldError 是运行时错误

编译时能通过，但运行时因为 class 文件结构不同，直接访问字段就崩了。

这正是 mixin/coremod 注入的典型坑。

结论

你没理解错，源码里确实写的是 lens.maxDamage，不是你记错。
问题出在 你现在运行的 mod 环境里 Item 类结构跟源码对不上 ——很可能 Hbm 自己的 Mixin 或你加的 Mixin 改了 Item 类，导致 maxDamage 字段不存在了。

怎么办

如果你只想避免崩溃，可以把你的调用改成：

lens.getMaxDamage();


或

lens.getItem().getMaxDamage(lens);


这两个是安全 API。

如果你不能改 Hbm 源码，那只能在你的 mixin / 反射里避免直接访问 lens.maxDamage。

想确认的话，你可以在运行时打印一下 Item.class.getDeclaredFields() 看看到底还有没有 maxDamage 这个字段。

要不要我帮你写一小段反射代码，把运行时的 Item 所有字段名都 dump 出来，这样你能一眼看出 maxDamage 有没有被移除？